<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Boggle</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;800;900&family=JetBrains+Mono:wght@500;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0f0f13;
            --bg-primary: #16161d;
            --bg-secondary: #1e1e27;
            --bg-elevated: #282833;
            --bg-hover: #32323f;
            --accent: #f97316;
            --accent-light: #fb923c;
            --accent-dark: #ea580c;
            --accent-glow: rgba(249, 115, 22, 0.35);
            --success: #22c55e;
            --success-glow: rgba(34, 197, 94, 0.3);
            --danger: #ef4444;
            --warning: #eab308;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --font-main: 'Nunito', sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
        }

        body {
            font-family: var(--font-main);
            background: var(--bg-deep);
            color: var(--text-primary);
            display: flex;
        }

        /* --- Menu Button (used in results) --- */
        .menu-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 10px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--bg-elevated);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-family: var(--font-main);
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .menu-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .screen {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* --- Game Screen --- */
        .game-layout {
            width: 100%;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            max-width: 600px;
            margin: 0 auto;
            padding: 12px;
            overflow: hidden;
        }

        .game-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .board-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 0;
        }

        .board-wrapper {
            position: relative;
            background: transparent;
            border: none;
            padding: 0;
            touch-action: none;
            width: 100%;
            height: 100%;
            max-width: min(90vw, 500px);
            max-height: 100%;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
            overflow: visible;
        }

        /* Readonly mode for Results screen */
        .board-wrapper.readonly {
            pointer-events: none;
        }

        .board {
            position: relative;
            display: grid;
            gap: 24px;
            user-select: none;
            width: 100%;
            height: 100%;
            max-width: min(65vh, 90vw);
            max-height: min(65vh, 90vw);
        }

        .board.size-4 {
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
        }

        .board.size-5 {
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 16px;
        }

        .die {
            width: 100%;
            aspect-ratio: 1;
            background: linear-gradient(145deg, var(--bg-elevated), var(--bg-secondary));
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: 900;
            color: var(--text-primary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.05);
            transition: transform 0.15s, background 0.15s, box-shadow 0.15s;
            cursor: pointer;
        }

        .die.selected {
            background: linear-gradient(145deg, var(--accent), var(--accent-dark));
            transform: scale(1.08);
            box-shadow: 0 0 25px var(--accent-glow), 0 8px 20px rgba(0, 0, 0, 0.4);
            z-index: 2;
        }

        .die.invalid {
            animation: shake 0.4s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-6px); }
            40%, 80% { transform: translateX(6px); }
        }

        .die.shuffle {
            animation: shuffle 0.5s ease;
        }

        @keyframes shuffle {
            0% { transform: rotateX(0) rotateY(0) scale(1); }
            50% { transform: rotateX(180deg) rotateY(90deg) scale(0.5); }
            100% { transform: rotateX(360deg) rotateY(180deg) scale(1); }
        }

        .selection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            overflow: visible;
        }

        .selection-path {
            fill: none;
            stroke: url(#holoGradient);
            stroke-width: 6; 
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.8));
        }

        .current-word {
            width: 100%;
            max-width: 320px;
            background: var(--bg-secondary);
            border: 2px solid var(--bg-elevated);
            border-radius: var(--radius-md);
            padding: 10px 20px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            font-weight: 800;
            letter-spacing: 3px;
            text-transform: uppercase;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .current-word.valid {
            border-color: var(--success);
            color: var(--success);
            box-shadow: 0 0 20px var(--success-glow);
        }

        .current-word.invalid {
            border-color: var(--danger);
            color: var(--danger);
        }

        .current-word.duplicate {
            border-color: var(--warning);
            color: var(--warning);
        }

        .info-section {
            flex: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
            max-height: 33vh;
            margin-top: 12px;
        }

        .game-controls {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            align-items: center;
            width: 100%;
            flex-shrink: 0;
        }

        .quit-btn {
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 700;
            color: var(--danger);
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s;
        }

        .quit-btn:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .score-row {
            display: flex;
            gap: 10px;
        }

        .score-card {
            flex: 1;
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            padding: 12px;
            text-align: center;
            border: 1px solid var(--bg-elevated);
        }

        .score-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .score-value {
            font-family: var(--font-mono);
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .timer {
            font-family: var(--font-mono);
            font-size: 2rem;
            font-weight: 700;
            min-width: 90px;
            text-align: right;
        }

        .timer.warning { color: var(--warning); }
        .timer.danger { color: var(--danger); animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .word-panel {
            flex: 1;
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            padding: 10px;
            border: 1px solid var(--bg-elevated);
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .word-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--bg-elevated);
            margin-bottom: 6px;
            flex-shrink: 0;
        }

        .word-panel-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            font-weight: 700;
        }

        .word-panel-count {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            color: var(--accent);
            font-weight: 700;
        }

        .word-tags {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-content: flex-start;
        }

        .word-tag {
            display: inline-flex;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            animation: popIn 0.25s ease;
        }

        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* --- Results Screen - Completely Redesigned for Portrait Mobile --- */
        .results-screen {
            padding: 0;
            justify-content: flex-start;
            overflow: hidden !important;
        }

        .results-content {
            width: 100%;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            padding: 12px;
            gap: 8px;
            overflow: hidden;
        }

        /* Section 1: Scores at top - compact */
        .results-header {
            text-align: center;
            flex-shrink: 0;
        }

        .results-title {
            font-size: 1.5rem;
            font-weight: 900;
            margin-bottom: 2px;
        }

        .results-title.win { color: var(--success); }
        .results-title.lose { color: var(--danger); }
        .results-title.tie { color: var(--warning); }
        .results-subtitle { color: var(--text-secondary); font-size: 0.85rem; }

        .final-scores {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            flex-shrink: 0;
        }

        .final-card {
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            padding: 10px;
            text-align: center;
            border: 2px solid var(--bg-elevated);
        }

        .final-card.winner {
            border-color: var(--success);
            background: rgba(34, 197, 94, 0.08);
        }

        .final-card .label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }

        .final-card .points {
            font-family: var(--font-mono);
            font-size: 1.8rem;
            font-weight: 700;
        }

        .final-card.winner .points { color: var(--success); }

        /* Section 2: Middle area - Board left, Definition right */
        .results-middle {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
            gap: 10px;
            flex-shrink: 0;
            min-height: 0;
            height: 30vh;
        }

        .results-board-container {
            aspect-ratio: 1;
            height: 30vh;
            max-height: 30vh;
            width: auto;
            max-width: 100%;
            min-width: 0;
            justify-self: center;
            overflow: hidden;
        }
        
        .results-board-container .board-wrapper {
            width: 100% !important;
            height: 100% !important;
        }

        .results-def-panel {
            background: var(--bg-elevated);
            border-radius: var(--radius-md);
            padding: 10px;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255,255,255,0.05);
            overflow: hidden;
            height: 30vh;
            min-width: 0;
        }

        .def-placeholder {
            margin: auto;
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
            font-size: 0.8rem;
            padding: 10px;
        }

        .def-content.hidden { display: none; }
        
        .def-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            min-width: 0;
            overflow: hidden;
        }
        
        .def-word-title {
            font-size: 0.85rem;
            font-weight: 800;
            color: var(--accent);
            text-transform: uppercase;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .def-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .def-alt-btn {
            padding: 3px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-elevated);
            border-radius: var(--radius-sm);
            color: var(--text-muted);
            font-size: 0.6rem;
            font-family: var(--font-main);
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .def-alt-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .def-alt-btn.hidden {
            display: none;
        }

        .def-body-scroll {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
            padding-right: 4px;
        }
        
        .def-body-scroll::-webkit-scrollbar {
            width: 4px;
        }
        
        .def-body-scroll::-webkit-scrollbar-thumb {
            background: var(--bg-elevated);
            border-radius: 2px;
        }
        
        .def-body-scroll::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        .def-entry { margin-bottom: 8px; }
        .def-pos { 
            font-size: 0.65rem; 
            color: var(--accent-light); 
            font-weight: 700; 
            text-transform: uppercase; 
            margin-bottom: 2px;
        }
        .def-text { 
            font-size: 0.8rem; 
            line-height: 1.4; 
            color: var(--text-primary); 
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Section 3: Word lists - scrollable boxes */
        .results-lists {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .results-list {
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            padding: 8px;
            border: 1px solid var(--bg-elevated);
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .results-list h3 {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--bg-elevated);
            flex-shrink: 0;
        }

        .results-words {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-content: flex-start;
            min-height: 0;
        }

        .result-word {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid transparent;
        }

        .result-word:hover {
            background: var(--bg-elevated);
            border-color: var(--accent);
        }

        .result-word.active-selection {
            background: var(--accent);
            color: white;
            border-color: var(--accent-light);
        }
        .result-word.active-selection .pts { color: white; }

        .result-word.crossed { text-decoration: line-through; opacity: 0.6; }
        .result-word.unique { border-left: 3px solid var(--success); }
        .result-word .pts { font-family: var(--font-mono); font-size: 0.6rem; color: var(--success); }

        /* Results header with buttons on sides */
        .results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 8px;
        }

        .results-header-center {
            text-align: center;
            flex: 1;
        }

        .results-top-btn {
            padding: 6px 12px;
            font-size: 0.7rem;
            font-weight: 700;
            font-family: var(--font-main);
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: 1px solid;
            min-width: 60px;
        }

        .results-top-btn.exit-btn {
            background: transparent;
            color: var(--text-secondary);
            border-color: var(--bg-elevated);
        }

        .results-top-btn.exit-btn:hover {
            border-color: var(--text-muted);
        }

        .results-top-btn.play-btn {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .results-top-btn.play-btn:hover {
            background: var(--accent-light);
        }

        .loading-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--text-muted);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Mobile game screen adjustments */
        @media (max-width: 600px) {
            :root { --menu-width: 60px; }
            
            /* Lock the game screen - no page scrolling during play */
            .game-layout { 
                padding: 6px; 
                height: 100dvh; 
                display: flex; 
                flex-direction: column;
                overflow: hidden;
            }
            .game-content { 
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                width: 100%; 
            }
            .board-section {
                flex: 2;
                min-height: 0;
            }
            .board-wrapper { 
                padding: 0; 
            }
            .board {
                max-width: min(58vh, 85vw);
                max-height: min(58vh, 85vw);
                gap: 16px;
            }
            .board.size-5 { 
                gap: 10px; 
                max-width: min(55vh, 85vw);
                max-height: min(55vh, 85vw);
            }
            .selection-svg { top: 0; left: 0; width: 100%; height: 100%; overflow: visible; }
            .selection-path { stroke-width: 5; }
            .current-word {
                padding: 8px 14px;
                min-height: 38px;
                font-size: 1.1rem;
                max-width: 280px;
                margin-bottom: 8px;
            }
            
            .info-section {
                flex: 1;
                min-height: 0;
                max-height: 30vh;
                display: flex;
                flex-direction: column;
                margin-top: 8px;
                overflow: hidden;
            }
            .game-controls { 
                display: flex; 
                flex-wrap: nowrap; 
                justify-content: space-between; 
                gap: 6px; 
                margin-bottom: 6px;
                flex-shrink: 0;
            }
            .score-card { padding: 6px; }
            .score-label { font-size: 0.55rem; }
            .score-value { font-size: 1rem; }
            .timer { min-width: 60px; font-size: 1.2rem; padding: 6px 10px; }
            .quit-btn { padding: 6px 10px; font-size: 0.75rem; }
            .word-panel { 
                flex: 1;
                min-height: 60px;
                overflow: hidden;
                padding: 8px;
            }
            .word-panel-header {
                padding-bottom: 4px;
                margin-bottom: 4px;
            }
            .word-panel-title { font-size: 0.6rem; }
            .word-panel-count { font-size: 0.75rem; }
            .word-tags {
                overflow-y: auto;
                gap: 3px;
            }
            .word-tag {
                padding: 3px 6px;
                font-size: 0.6rem;
            }
            
            /* Results screen - ensure no scrolling */
            .results-screen {
                overflow: hidden !important;
            }
            
            .results-content {
                height: 100dvh;
                padding: 8px;
                gap: 6px;
            }
            
            .results-title {
                font-size: 1.3rem;
            }
            
            .results-subtitle {
                font-size: 0.75rem;
            }
            
            .final-card {
                padding: 8px;
            }
            
            .final-card .points {
                font-size: 1.5rem;
            }
            
            .results-middle {
                height: 26vh;
            }
            
            .results-board-container {
                height: 26vh;
                max-height: 26vh;
            }
            
            .results-def-panel {
                height: 26vh;
            }
            
            .results-board-container .board {
                gap: 6px;
            }
            
            .results-board-container .die {
                font-size: 0.9rem;
                border-radius: 6px;
            }
        }

        /* Very small screens */
        @media (max-height: 700px) {
            .results-content {
                gap: 4px;
            }
            
            .results-header {
                margin-bottom: 0;
            }
            
            .results-title {
                font-size: 1.2rem;
            }
            
            .final-card {
                padding: 6px;
            }
            
            .final-card .points {
                font-size: 1.3rem;
            }
            
            .final-card .label {
                font-size: 0.6rem;
            }
            
            .results-middle {
                height: 22vh;
            }
            
            .results-board-container {
                height: 22vh;
                max-height: 22vh;
            }
            
            .results-def-panel {
                height: 22vh;
            }
            
            .results-top-btn {
                padding: 5px 10px;
                font-size: 0.65rem;
                min-width: 50px;
            }
        }

    </style>
    
    <!-- Shared Module CSS -->
    <link rel="stylesheet" href="/v2/css/auth.css">
    <link rel="stylesheet" href="/v2/css/inventory.css">
</head>


<body>
    <main class="main">
        <div class="screen" id="gameScreen">
            <div class="game-layout">
                <div class="game-content">
                    <div class="board-section" id="gameBoardSection">
                        <div class="board-wrapper" id="boardWrapper">
                            <svg class="selection-svg">
                                <defs>
                                    <linearGradient id="holoGradient" gradientUnits="userSpaceOnUse" x1="0" y1="0" x2="400" y2="400">
                                        <stop offset="0%" stop-color="#ff0000" />
                                        <stop offset="20%" stop-color="#ffff00" />
                                        <stop offset="40%" stop-color="#00ff00" />
                                        <stop offset="60%" stop-color="#00ffff" />
                                        <stop offset="80%" stop-color="#0000ff" />
                                        <stop offset="100%" stop-color="#ff00ff" />
                                    </linearGradient>
                                </defs>
                                <polyline class="selection-path" id="selectionPath" points="" />
                            </svg>
                            </svg>
                            <div class="board" id="board"></div>
                        </div>
                        <div class="current-word" id="currentWord">&nbsp;</div>
                    </div>

                    <div class="info-section">
                        <div class="game-controls">
                            <div class="score-card">
                                <div class="score-label">Score</div>
                                <div class="score-value" id="liveScore">0</div>
                            </div>
                            <div class="timer" id="timer">3:00</div>
                            <button class="quit-btn" onclick="window.location.href='/games'">Quit</button>
                        </div>
                        <div class="word-panel">
                            <div class="word-panel-header">
                                <span class="word-panel-title">Your Words</span>
                                <span class="word-panel-count" id="wordCount">0</span>
                            </div>
                            <div class="word-tags" id="wordTags"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="screen hidden results-screen" id="resultsScreen">
            <div class="results-content">
                <!-- Section 1: Title with buttons on sides -->
                <div class="results-header">
                    <button class="results-top-btn exit-btn" onclick="window.location.href='/games'">Exit</button>
                    <div class="results-header-center">
                        <h1 class="results-title" id="resultsTitle">Time's Up!</h1>
                        <p class="results-subtitle" id="resultsSubtitle"></p>
                    </div>
                    <button class="results-top-btn play-btn" onclick="restartGame()">Rematch</button>
                </div>
                
                <div class="final-scores">
                    <div class="final-card" id="playerCard">
                        <div class="label">You</div>
                        <div class="points" id="playerFinalScore">0</div>
                    </div>
                    <div class="final-card" id="npcCard">
                        <div class="label">Computer</div>
                        <div class="points" id="npcFinalScore">0</div>
                    </div>
                </div>

                <!-- Section 2: Board (left) + Definition (right) -->
                <div class="results-middle">
                    <div id="resultsBoardContainer" class="results-board-container"></div>
                    
                    <div class="results-def-panel" id="resultsDefPanel">
                        <div class="def-placeholder" id="defPlaceholder">Tap a word to see its path and definition</div>
                        <div class="def-content hidden" id="defContent">
                            <div class="def-header">
                                <div class="def-word-title" id="resDefWord"></div>
                                <button class="def-alt-btn hidden" id="defAltBtn" onclick="fetchAltDefinition()">Alt</button>
                            </div>
                            <div class="def-body-scroll" id="resDefBody"></div>
                        </div>
                    </div>
                </div>

                <!-- Section 3: Word Lists (scrollable boxes) -->
                <div class="results-lists">
                    <div class="results-list">
                        <h3>Your Words (<span id="playerWordCount">0</span>)</h3>
                        <div class="results-words" id="playerResults"></div>
                    </div>
                    <div class="results-list">
                        <h3>Computer (<span id="npcWordCount">0</span>)</h3>
                        <div class="results-words" id="npcResults"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Shared JS Modules -->
    <script src="/v2/js/config.js"></script>
    <script src="/v2/js/auth.js"></script>
    <script src="/v2/js/inventory.js"></script>
    <script src="/v2/js/items.js"></script>

    <script>
        const DICE_4x4 = [['A', 'A', 'E', 'E', 'G', 'N'], ['A', 'B', 'B', 'J', 'O', 'O'], ['A', 'C', 'H', 'O', 'P', 'S'], ['A', 'F', 'F', 'K', 'P', 'S'], ['A', 'O', 'O', 'T', 'T', 'W'], ['C', 'I', 'M', 'O', 'T', 'U'], ['D', 'E', 'I', 'L', 'R', 'X'], ['D', 'E', 'L', 'R', 'V', 'Y'], ['D', 'I', 'S', 'T', 'T', 'Y'], ['E', 'E', 'G', 'H', 'N', 'W'], ['E', 'E', 'I', 'N', 'S', 'U'], ['E', 'H', 'R', 'T', 'V', 'W'], ['E', 'I', 'O', 'S', 'S', 'T'], ['E', 'L', 'R', 'T', 'T', 'Y'], ['H', 'I', 'M', 'N', 'U', 'Qu'], ['H', 'L', 'N', 'N', 'R', 'Z']];
        const DICE_5x5 = [['A', 'A', 'A', 'F', 'R', 'S'], ['A', 'A', 'E', 'E', 'E', 'E'], ['A', 'A', 'F', 'I', 'R', 'S'], ['A', 'D', 'E', 'N', 'N', 'N'], ['A', 'E', 'E', 'E', 'E', 'M'], ['A', 'E', 'E', 'G', 'M', 'U'], ['A', 'E', 'G', 'M', 'N', 'N'], ['A', 'F', 'I', 'R', 'S', 'Y'], ['B', 'J', 'K', 'Qu', 'X', 'Z'], ['C', 'C', 'N', 'S', 'T', 'W'], ['C', 'E', 'I', 'I', 'L', 'T'], ['C', 'E', 'I', 'L', 'P', 'T'], ['C', 'E', 'I', 'P', 'S', 'T'], ['D', 'H', 'H', 'N', 'O', 'T'], ['D', 'H', 'H', 'L', 'O', 'R'], ['D', 'H', 'L', 'N', 'O', 'R'], ['D', 'D', 'L', 'N', 'O', 'R'], ['E', 'I', 'I', 'I', 'T', 'T'], ['E', 'M', 'O', 'T', 'T', 'T'], ['E', 'N', 'S', 'S', 'S', 'U'], ['F', 'I', 'P', 'R', 'S', 'Y'], ['G', 'O', 'R', 'R', 'V', 'W'], ['H', 'I', 'P', 'R', 'R', 'Y'], ['N', 'O', 'O', 'T', 'U', 'W'], ['O', 'O', 'O', 'T', 'T', 'U']];
        
        class Logger {
            constructor() { this.logs = []; }
            add(level, msg, stack = null) {
                const entry = { time: new Date().toISOString(), level, msg, stack };
                this.logs.push(entry);
                if (level === 'error') console.error(msg, stack || ''); else console.log(msg);
            }
            log(msg) { this.add('info', msg); }
            error(msg, err) { this.add('error', msg, err?.stack || err); }
            download() {
                if (this.logs.length === 0) { alert('No logs to download.'); return; }
                const text = this.logs.map(l => `[${l.time}] ${l.level.toUpperCase()}: ${l.msg}${l.stack ? '\nStack: ' + l.stack : ''}`).join('\n\n');
                const blob = new Blob([text], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `boggle_log.txt`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
            }
        }
        const logger = new Logger();
        window.onerror = (msg, url, line, col, err) => { logger.error(`Global Error: ${msg} (${url}:${line}:${col})`, err); return false; };

        // --- Game Logic ---
        // Boggle game constants
        const GAME_TIME = 180;
        const MIN_LEN = 3;
        const SCORE_TABLE = { 3: 1, 4: 1, 5: 2, 6: 3, 7: 5 };
        const getWordScore = len => len >= 8 ? 11 : (SCORE_TABLE[len] || 0);
        const DIFFICULTY = { easy: 0.15, medium: 0.25, hard: 0.35, test: 0.5 };

        function getAdjacents(idx, gridSize) {
            const adjacents = [];
            const row = Math.floor(idx / gridSize);
            const col = idx % gridSize;
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const newRow = row + dr, newCol = col + dc;
                    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {
                        adjacents.push(newRow * gridSize + newCol);
                    }
                }
            }
            return adjacents;
        }

        class Trie {
            constructor() { this.root = {}; }
            insert(word) { let n = this.root; for (const c of word) { n = n[c] = n[c] || {}; } n.$ = true; }
            has(word) { let n = this.root; for (const c of word) { if (!n[c]) return false; n = n[c]; } return !!n.$; }
            hasPrefix(p) { let n = this.root; for (const c of p) { if (!n[c]) return false; n = n[c]; } return true; }
        }

        const state = { board: [], path: [], selecting: false, playerWords: new Set(), npcWords: new Set(), allWords: [], time: GAME_TIME, timer: null, active: false, difficulty: 'medium', gridSize: 4, trie: null, loaded: false, currentScreen: 'game', playerName: '' };
        const $ = id => document.getElementById(id);
        
        const dom = { 
            gameScreen: $('gameScreen'), resultsScreen: $('resultsScreen'), 
            board: $('board'), boardWrapper: $('boardWrapper'), 
            selectionPath: $('selectionPath'), currentWord: $('currentWord'), timer: $('timer'), 
            liveScore: $('liveScore'), wordTags: $('wordTags'), wordCount: $('wordCount'), 
            resultsTitle: $('resultsTitle'), resultsSubtitle: $('resultsSubtitle'), playerCard: $('playerCard'), 
            npcCard: $('npcCard'), playerFinalScore: $('playerFinalScore'), npcFinalScore: $('npcFinalScore'), 
            playerWordCount: $('playerWordCount'), npcWordCount: $('npcWordCount'), playerResults: $('playerResults'), 
            npcResults: $('npcResults'), gameBoardSection: $('gameBoardSection'), resultsBoardContainer: $('resultsBoardContainer'),
            defPlaceholder: $('defPlaceholder'), defContent: $('defContent'), resDefWord: $('resDefWord'), 
            resDefBody: $('resDefBody'), defAltBtn: $('defAltBtn')
        };
        const SFX = { play: n => console.log(`[SFX] ${n}`) };

        function showScreen(name) {
            state.currentScreen = name;
            dom.gameScreen.classList.toggle('hidden', name !== 'game');
            dom.resultsScreen.classList.toggle('hidden', name !== 'results');
            
            // Logic to move board
            if (name === 'results') {
                dom.resultsBoardContainer.appendChild(dom.boardWrapper);
                dom.boardWrapper.classList.add('readonly');
                // Clear any selection
                state.path = []; updateSelectionPath(); 
                document.querySelectorAll('.die.selected').forEach(d => d.classList.remove('selected'));
                dom.defContent.classList.add('hidden');
                dom.defPlaceholder.style.display = 'block';
            } else {
                // Ensure board is back in game section
                dom.gameBoardSection.insertBefore(dom.boardWrapper, dom.currentWord);
                dom.boardWrapper.classList.remove('readonly');
                state.path = []; updateSelectionPath();
                document.querySelectorAll('.die.selected').forEach(d => d.classList.remove('selected'));
            }
        }

        async function loadDictionary() {
            try {
                const res = await fetch('https://raw.githubusercontent.com/christianp/nulac/master/2of12inf.txt');
                const text = await res.text();
                state.trie = new Trie();
                let count = 0;
                for (const line of text.split('\n')) { 
                    const w = line.trim().toUpperCase(); 
                    if (w.length >= MIN_LEN && /^[A-Z]+$/.test(w)) { state.trie.insert(w); count++; } 
                }
                state.loaded = true;
                console.log(`[BOGGLE] Dictionary loaded: ${count} words`);
            } catch (e) { 
                console.error('[BOGGLE] Dictionary load failed:', e);
            }
        }

        function generateBoard() {
            const dice = state.gridSize === 5 ? DICE_5x5 : DICE_4x4;
            const shuffled = [...dice].sort(() => Math.random() - 0.5);
            state.board = shuffled.map(die => die[Math.floor(Math.random() * 6)]);
        }

        function solveBoard() {
            const found = new Set(), board = state.board.map(c => c === 'Qu' ? 'QU' : c);
            const gridSize = state.gridSize;
            function dfs(idx, path, word) {
                word += board[idx];
                if (!state.trie.hasPrefix(word)) return;
                if (word.length >= MIN_LEN && state.trie.has(word)) found.add(word);
                for (const adj of getAdjacents(idx, gridSize)) { 
                    if (!path.has(adj)) { path.add(adj); dfs(adj, path, word); path.delete(adj); } 
                }
            }
            for (let i = 0; i < gridSize * gridSize; i++) dfs(i, new Set([i]), '');
            state.allWords = [...found].sort((a, b) => b.length - a.length || a.localeCompare(b));
        }

        // DFS to find path for a specific word for UI highlighting
        function findPathForWord(targetWord) {
            const board = state.board.map(c => c === 'Qu' ? 'QU' : c);
            const gridSize = state.gridSize;
            let resultPath = null;
            
            function search(idx, currentPath, currentStr) {
                if (resultPath) return; // Already found
                
                const newStr = currentStr + board[idx];
                if (!targetWord.startsWith(newStr)) return;
                
                if (newStr === targetWord) {
                    resultPath = [...currentPath];
                    return;
                }
                
                for (const adj of getAdjacents(idx, gridSize)) {
                    if (!currentPath.includes(adj)) {
                        currentPath.push(adj);
                        search(adj, currentPath, newStr);
                        currentPath.pop();
                    }
                }
            }

            for (let i = 0; i < board.length; i++) {
                if (board[i] === targetWord.substring(0, board[i].length)) {
                    search(i, [i], "");
                }
            }
            return resultPath;
        }

        function selectNPCWords() {
            const pct = DIFFICULTY[state.difficulty];
            if (state.difficulty === 'test') {
                // Test mode: NPC gets only 1 random word
                const words = [...state.allWords];
                state.npcWords = new Set([words[Math.floor(Math.random() * words.length)]]);
            } else {
                state.npcWords = new Set(state.allWords.filter(w => Math.random() < pct * (1 - (w.length - 3) * 0.05)));
            }
        }

        function startGame() {
            if (!state.loaded) return;
            generateBoard();
            solveBoard();
            selectNPCWords();
            state.playerWords.clear(); state.path = [];
            state.time = state.difficulty === 'test' ? 10 : GAME_TIME;
            state.active = true;
            renderBoard(); updateUI();
            dom.wordTags.innerHTML = ''; dom.currentWord.textContent = '\u00A0'; 
            dom.currentWord.className = 'current-word'; dom.timer.className = 'timer';
            showScreen('game');
            document.querySelectorAll('.die').forEach((d, i) => { d.classList.add('shuffle'); setTimeout(() => d.classList.remove('shuffle'), 500 + i * 50); });
            setTimeout(() => { state.timer = setInterval(tick, 1000); }, 800);
        }

        function restartGame() {
            // Restart with same settings
            startGame();
        }

        function tick() { state.time--; updateTimer(); if (state.time <= 0) endGame(); }
        function updateTimer() { 
            const m = Math.floor(state.time / 60), s = state.time % 60; 
            dom.timer.textContent = `${m}:${s.toString().padStart(2, '0')}`; 
            dom.timer.classList.toggle('warning', state.time <= 60 && state.time > 30); 
            dom.timer.classList.toggle('danger', state.time <= 30); 
        }
        function endGame() { state.active = false; clearInterval(state.timer); SFX.play('gameOver'); showResults(); }
        function quitGame() { state.active = false; clearInterval(state.timer); window.location.href = '/games'; }

        function showResults() {
            const shared = new Set([...state.playerWords].filter(w => state.npcWords.has(w)));
            let playerScore = 0, npcScore = 0;
            const playerWordsArr = [...state.playerWords].sort((a, b) => b.length - a.length);
            dom.playerResults.innerHTML = playerWordsArr.map(w => { 
                const x = shared.has(w), pts = x ? 0 : getWordScore(w.length); 
                playerScore += pts; 
                return `<span class="result-word ${x ? 'crossed' : 'unique'}" data-word="${w}">${w}${pts ? `<span class="pts">+${pts}</span>` : ''}</span>`; 
            }).join('');
            
            const npcWordsArr = [...state.npcWords].sort((a, b) => b.length - a.length);
            dom.npcResults.innerHTML = npcWordsArr.map(w => { 
                const x = shared.has(w), pts = x ? 0 : getWordScore(w.length); 
                npcScore += pts; 
                return `<span class="result-word ${x ? 'crossed' : 'unique'}" data-word="${w}">${w}${pts ? `<span class="pts">+${pts}</span>` : ''}</span>`; 
            }).join('');
            
            // Save scores to state for leaderboard
            state.playerScore = playerScore;
            state.npcScore = npcScore;
            
            dom.playerFinalScore.textContent = playerScore; dom.npcFinalScore.textContent = npcScore;
            dom.playerWordCount.textContent = playerWordsArr.length; dom.npcWordCount.textContent = npcWordsArr.length;
            dom.playerCard.classList.toggle('winner', playerScore > npcScore); dom.npcCard.classList.toggle('winner', npcScore > playerScore);
            
            if (playerScore > npcScore) { dom.resultsTitle.textContent = 'You Win!'; dom.resultsTitle.className = 'results-title win'; dom.resultsSubtitle.textContent = `You beat the computer by ${playerScore - npcScore} points!`; }
            else if (npcScore > playerScore) { dom.resultsTitle.textContent = 'You Lose'; dom.resultsTitle.className = 'results-title lose'; dom.resultsSubtitle.textContent = `The computer won by ${npcScore - playerScore} points.`; }
            else { dom.resultsTitle.textContent = "It's a Tie!"; dom.resultsTitle.className = 'results-title tie'; dom.resultsSubtitle.textContent = 'Great minds think alike!'; }
            
            // Auto-save score to leaderboard
            autoSaveScore();
            
            // Request item rolls
            setTimeout(() => requestItemsAfterGame(), 500);
            
            showScreen('results');
        }

        function renderBoard() {
            const size = state.gridSize;
            dom.board.className = `board size-${size}`;
            dom.boardWrapper.className = `board-wrapper size-${size}`;
            dom.board.innerHTML = state.board.map((l, i) => `<div class="die" data-idx="${i}">${l}</div>`).join('');
        }
        function getDie(idx) {
            return dom.board.querySelector(`.die[data-idx="${idx}"]`);
        }
        function getDieCenter(idx) { 
            const d = getDie(idx);
            if (!d) return { x: 0, y: 0 };
            const r = d.getBoundingClientRect(); 
            const wrapper = dom.boardWrapper.getBoundingClientRect();
            const board = dom.board.getBoundingClientRect();
            // SVG is positioned from wrapper top-left, so we need offset from wrapper
            // But board is centered in wrapper, so add the board's offset
            const boardOffsetX = board.left - wrapper.left;
            const boardOffsetY = board.top - wrapper.top;
            return { 
                x: boardOffsetX + (r.left - board.left) + r.width / 2, 
                y: boardOffsetY + (r.top - board.top) + r.height / 2 
            }; 
        }
        function updateSelectionPath(cursorX, cursorY) { 
            if (state.path.length < 1) { 
                dom.selectionPath.setAttribute('points', ''); 
                return; 
            }
            // Update SVG viewBox to match wrapper size
            const wrapper = dom.boardWrapper.getBoundingClientRect();
            const svg = dom.boardWrapper.querySelector('.selection-svg');
            svg.setAttribute('viewBox', `0 0 ${wrapper.width} ${wrapper.height}`);
            
            // Build points from selected dice
            const points = state.path.map(i => { 
                const c = getDieCenter(i); 
                return `${c.x},${c.y}`; 
            });
            
            // Add cursor position if provided (trailing line)
            if (cursorX !== undefined && cursorY !== undefined && state.selecting) {
                const cursorRelX = cursorX - wrapper.left;
                const cursorRelY = cursorY - wrapper.top;
                points.push(`${cursorRelX},${cursorRelY}`);
            }
            
            dom.selectionPath.setAttribute('points', points.join(' '));
        }
        function getCurrentWord() { return state.path.map(i => state.board[i] === 'Qu' ? 'QU' : state.board[i]).join(''); }
        function updateCurrentWordDisplay() { const w = getCurrentWord(); dom.currentWord.textContent = w || '\u00A0'; dom.currentWord.className = 'current-word'; }
        function updateUI() { let s = 0; state.playerWords.forEach(w => s += getWordScore(w.length)); dom.liveScore.textContent = s; dom.wordCount.textContent = state.playerWords.size; }
        function addWordTag(word) { const t = document.createElement('span'); t.className = 'word-tag'; t.textContent = word; dom.wordTags.prepend(t); }
        function clearSelection() { state.path = []; document.querySelectorAll('.die.selected').forEach(d => d.classList.remove('selected')); updateSelectionPath(); updateCurrentWordDisplay(); }
        
        function submitWord() {
            const word = getCurrentWord();
            if (word.length < MIN_LEN) { flashInvalid(); SFX.play('invalid'); }
            else if (state.playerWords.has(word)) { dom.currentWord.classList.add('duplicate'); SFX.play('duplicate'); }
            else if (state.trie.has(word)) { state.playerWords.add(word); addWordTag(word); updateUI(); dom.currentWord.classList.add('valid'); SFX.play('valid'); }
            else { flashInvalid(); SFX.play('invalid'); }
            setTimeout(clearSelection, 300);
        }
        function flashInvalid() { dom.currentWord.classList.add('invalid'); state.path.forEach(i => { const d = getDie(i); if(d) { d.classList.add('invalid'); setTimeout(() => d.classList.remove('invalid'), 400); } }); }

        function getIdxFromPoint(x, y) { const el = document.elementFromPoint(x, y); return el?.classList.contains('die') ? parseInt(el.dataset.idx) : null; }
        function handleStart(x, y) { if (!state.active) return; const idx = getIdxFromPoint(x, y); if (idx !== null) { state.selecting = true; state.path = [idx]; getDie(idx).classList.add('selected'); updateSelectionPath(x, y); updateCurrentWordDisplay(); SFX.play('select'); } }
        function handleMove(x, y) {
            if (!state.selecting || !state.active) return;
            
            // Always update the trailing line to cursor
            updateSelectionPath(x, y);
            
            const idx = getIdxFromPoint(x, y); if (idx === null) return;
            const last = state.path[state.path.length - 1]; if (idx === last) return;
            if (state.path.length > 1 && idx === state.path[state.path.length - 2]) { getDie(last).classList.remove('selected'); state.path.pop(); updateSelectionPath(x, y); updateCurrentWordDisplay(); SFX.play('select'); return; }
            const adjacents = getAdjacents(last, state.gridSize);
            if (adjacents.includes(idx) && !state.path.includes(idx)) { state.path.push(idx); getDie(idx).classList.add('selected'); updateSelectionPath(x, y); updateCurrentWordDisplay(); SFX.play('select'); }
        }
        function handleEnd() { if (!state.selecting) return; state.selecting = false; if (state.path.length > 0) submitWord(); }

        dom.boardWrapper.addEventListener('mousedown', e => { e.preventDefault(); handleStart(e.clientX, e.clientY); });
        document.addEventListener('mousemove', e => { if (state.selecting) { e.preventDefault(); handleMove(e.clientX, e.clientY); } });
        document.addEventListener('mouseup', handleEnd);
        dom.boardWrapper.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        dom.boardWrapper.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        dom.boardWrapper.addEventListener('touchend', e => { e.preventDefault(); handleEnd(); });

        // Track which source was used for current word
        let currentDefWord = '';
        let currentDefSource = ''; // 'primary' or 'datamuse'

        async function fetchDefinitionForPanel(word) {
            currentDefWord = word;
            currentDefSource = '';
            dom.defPlaceholder.style.display = 'none';
            dom.defContent.classList.remove('hidden');
            dom.resDefWord.textContent = word;
            dom.defAltBtn.classList.add('hidden');
            dom.resDefBody.innerHTML = '<div class="def-loading"><span class="loading-spinner"></span>Loading...</div>';

            try {
                const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word.toLowerCase()}`);
                if (!res.ok) throw new Error('Primary API failed');
                const data = await res.json();
                
                // Prioritize definitions
                const bestEntry = data.sort((a, b) => {
                    const getScore = (entry) => {
                        let score = 0;
                        const text = JSON.stringify(entry).toLowerCase();
                        if (text.includes('archaic') || text.includes('obsolete')) score -= 1000;
                        if (entry.meanings) entry.meanings.forEach(m => m.definitions.forEach(d => score += (d.definition || '').length));
                        return score;
                    };
                    return getScore(b) - getScore(a);
                })[0] || data[0];

                let html = '';
                for (const m of bestEntry.meanings.slice(0, 2)) {
                    html += `<div class="def-entry"><div class="def-pos">${m.partOfSpeech}</div>`;
                    for (const d of m.definitions.slice(0, 1)) {
                        html += `<div class="def-text"> ${d.definition}</div>`;
                    }
                    html += '</div>';
                }
                dom.resDefBody.innerHTML = html;
                currentDefSource = 'primary';
                dom.defAltBtn.classList.remove('hidden');
                dom.defAltBtn.textContent = 'Alt';
            } catch {
                // Primary failed, try Datamuse
                try {
                    const res2 = await fetch(`https://api.datamuse.com/words?sp=${word.toLowerCase()}&md=d`);
                    const data2 = await res2.json();
                    const match = data2.find(w => w.word.toLowerCase() === word.toLowerCase() && w.defs);
                    if (match && match.defs) {
                        let html = '';
                        for (const def of match.defs.slice(0, 2)) {
                            const [pos, text] = def.split('\t');
                            html += `<div class="def-entry"><div class="def-pos">${pos}</div><div class="def-text"> ${text}</div></div>`;
                        }
                        dom.resDefBody.innerHTML = html;
                        currentDefSource = 'datamuse';
                        dom.defAltBtn.classList.remove('hidden');
                        dom.defAltBtn.textContent = 'Alt';
                    } else throw new Error();
                } catch {
                    dom.resDefBody.innerHTML = '<div class="def-error" style="color:var(--text-muted)">Definition unavailable.</div>';
                    currentDefSource = '';
                    dom.defAltBtn.classList.add('hidden');
                }
            }
        }

        async function fetchAltDefinition() {
            if (!currentDefWord) return;
            
            dom.defAltBtn.classList.add('hidden');
            dom.resDefBody.innerHTML = '<div class="def-loading"><span class="loading-spinner"></span>Loading...</div>';
            
            if (currentDefSource === 'primary') {
                // Try Datamuse as alternate
                try {
                    const res = await fetch(`https://api.datamuse.com/words?sp=${currentDefWord.toLowerCase()}&md=d`);
                    const data = await res.json();
                    const match = data.find(w => w.word.toLowerCase() === currentDefWord.toLowerCase() && w.defs);
                    if (match && match.defs) {
                        let html = '';
                        for (const def of match.defs.slice(0, 3)) {
                            const [pos, text] = def.split('\t');
                            html += `<div class="def-entry"><div class="def-pos">${pos}</div><div class="def-text"> ${text}</div></div>`;
                        }
                        dom.resDefBody.innerHTML = html;
                        currentDefSource = 'datamuse';
                        dom.defAltBtn.classList.remove('hidden');
                        dom.defAltBtn.textContent = 'Alt';
                    } else throw new Error();
                } catch {
                    dom.resDefBody.innerHTML = '<div class="def-error" style="color:var(--text-muted)">Alternate definition unavailable.</div>';
                    dom.defAltBtn.classList.remove('hidden');
                    dom.defAltBtn.textContent = 'Alt';
                }
            } else if (currentDefSource === 'datamuse') {
                // Try primary as alternate
                try {
                    const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${currentDefWord.toLowerCase()}`);
                    if (!res.ok) throw new Error();
                    const data = await res.json();
                    const bestEntry = data[0];
                    
                    let html = '';
                    for (const m of bestEntry.meanings.slice(0, 2)) {
                        html += `<div class="def-entry"><div class="def-pos">${m.partOfSpeech}</div>`;
                        for (const d of m.definitions.slice(0, 1)) {
                            html += `<div class="def-text"> ${d.definition}</div>`;
                        }
                        html += '</div>';
                    }
                    dom.resDefBody.innerHTML = html;
                    currentDefSource = 'primary';
                    dom.defAltBtn.classList.remove('hidden');
                    dom.defAltBtn.textContent = 'Alt';
                } catch {
                    dom.resDefBody.innerHTML = '<div class="def-error" style="color:var(--text-muted)">Primary definition unavailable.</div>';
                    dom.defAltBtn.classList.remove('hidden');
                    dom.defAltBtn.textContent = 'Alt';
                }
            }
        }

        // Handle clicking words in results
        document.addEventListener('click', e => {
            const wordEl = e.target.closest('.result-word');
            if (wordEl && dom.resultsScreen.contains(wordEl)) {
                // Highlight Word
                document.querySelectorAll('.result-word').forEach(el => el.classList.remove('active-selection'));
                wordEl.classList.add('active-selection');
                
                const word = wordEl.dataset.word;
                
                // 1. Find and Highlight on Board
                document.querySelectorAll('.die.selected').forEach(d => d.classList.remove('selected'));
                const path = findPathForWord(word);
                if (path) {
                    state.path = path;
                    updateSelectionPath();
                    path.forEach(idx => { const d = getDie(idx); if(d) d.classList.add('selected'); });
                } else {
                    state.path = [];
                    updateSelectionPath();
                }

                // 2. Fetch Definition
                fetchDefinitionForPanel(word);
            }
        });

        // Prevent page scroll during game - only allow scrolling in word-tags panel
        document.addEventListener('touchmove', e => {
            if (state.currentScreen === 'game') {
                // Allow scrolling only inside the word tags container
                const isWordTags = e.target.closest('.word-tags');
                if (!isWordTags) {
                    e.preventDefault();
                }
            }
        }, { passive: false });

        // Prevent pull-to-refresh and overscroll
        document.body.addEventListener('touchmove', e => {
            if (state.currentScreen === 'game' && !e.target.closest('.word-tags')) {
                e.preventDefault();
            }
        }, { passive: false });

        // --- Save Score (sends to server via auth WebSocket) ---
        function saveScore(scoreData) {
            if (typeof sendAuthMessage === 'function') {
                sendAuthMessage({
                    type: 'submit_score',
                    mode: 'singleplayer',
                    name: scoreData.name || getPlayerName() || 'Anonymous',
                    score: scoreData.score,
                    wordCount: scoreData.wordCount,
                    longestWord: scoreData.longestWord,
                    gridSize: scoreData.gridSize,
                    difficulty: scoreData.difficulty,
                    won: scoreData.won
                });
            }
        }

        function autoSaveScore() {
            const won = state.playerScore > state.npcScore;
            saveScore({
                name: getPlayerName() || 'Anonymous',
                score: state.playerScore,
                wordCount: state.playerWords.size,
                longestWord: [...state.playerWords].sort((a, b) => b.length - a.length)[0] || '',
                gridSize: state.gridSize,
                difficulty: state.difficulty,
                won: won
            });
        }

        // --- Item Rewards (uses shared modules) ---
        function requestItemsAfterGame() {
            if (!isAuthenticated()) return;
            
            const won = state.playerScore > state.npcScore;
            const words = [...state.playerWords];
            const baseRolls = calculateItemRolls(won, state.difficulty);
            
            if (baseRolls === 0) return;
            requestItemRolls(baseRolls, words);
        }
        
        // Callback when item earned popup closes
        onItemEarnedClosed = function() {
            // Nothing special needed
        };

        // --- Init ---
        console.log('[BOGGLE] Starting init...');
        loadDictionary();
        console.log('[BOGGLE] Dictionary loading...');
        initAuth();
        console.log('[BOGGLE] Auth initialized');
        initInventory(); // Need this for item earned popup
        console.log('[BOGGLE] Inventory initialized');
        
        // Get game settings from URL params or localStorage
        const urlParams = new URLSearchParams(window.location.search);
        state.gridSize = parseInt(urlParams.get('size')) || parseInt(localStorage.getItem('boggle_gridSize')) || 4;
        state.difficulty = urlParams.get('diff') || localStorage.getItem('boggle_difficulty') || 'medium';
        console.log('[BOGGLE] Settings:', state.gridSize, state.difficulty);
        
        // Save settings
        localStorage.setItem('boggle_gridSize', state.gridSize);
        localStorage.setItem('boggle_difficulty', state.difficulty);
        
        // Start game when dictionary is loaded
        function waitAndStart() {
            console.log('[BOGGLE] Waiting for dictionary, loaded:', state.loaded);
            if (state.loaded) {
                console.log('[BOGGLE] Starting game!');
                startGame();
            } else {
                setTimeout(waitAndStart, 100);
            }
        }
        waitAndStart();
    </script>
</body>
</html>